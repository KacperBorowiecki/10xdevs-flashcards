# PostgreSQL Database Schema for 10x-cards

This document outlines the database schema for the 10x-cards application, designed based on the project requirements, session notes, and technological stack.

## 0. Preliminary Definitions

### ENUM Types

These ENUM types are used to define allowed values for specific columns, ensuring data consistency.

```sql
CREATE TYPE flashcard_source_enum AS ENUM ('manual', 'ai_suggestion');
CREATE TYPE flashcard_status_enum AS ENUM ('active', 'pending_review', 'rejected');
```

### Helper Functions

Function to automatically update the `updated_at` timestamp on row modification.

```sql
CREATE OR REPLACE FUNCTION trigger_set_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

## 1. Tables

Below are the table definitions, including columns, data types, primary keys, foreign keys, and constraints.

### a. `auth.users` (Provided by Supabase)

This table is managed by Supabase and stores user authentication information.
-   `id` (UUID, Primary Key): Unique identifier for the user.
-   `email` (TEXT): User's email address.
-   `encrypted_password` (TEXT): User's encrypted password.
-   `created_at` (TIMESTAMPTZ): Timestamp of user registration.
-   `last_sign_in_at` (TIMESTAMPTZ): Timestamp of the user's last sign-in.
-   Other Supabase-specific columns.

### b. `source_texts`

Stores the raw text provided by users for AI-powered flashcard generation.

```sql
CREATE TABLE source_texts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    text_content TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TRIGGER set_timestamp_source_texts
BEFORE UPDATE ON source_texts
FOR EACH ROW
EXECUTE FUNCTION trigger_set_timestamp();
```

### c. `flashcards`

Stores individual flashcards, whether created manually or generated by AI.

```sql
CREATE TABLE flashcards (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    source_text_id UUID REFERENCES source_texts(id) ON DELETE SET NULL, -- NULL if manually created
    front_content VARCHAR(500) NOT NULL,
    back_content VARCHAR(1000) NOT NULL,
    source flashcard_source_enum NOT NULL,
    status flashcard_status_enum NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    CONSTRAINT check_flashcard_source_and_status CHECK (
        (source = 'manual' AND status = 'active' AND source_text_id IS NULL) OR
        (source = 'ai_suggestion' AND source_text_id IS NOT NULL AND status IN ('active', 'pending_review', 'rejected'))
    )
);

CREATE TRIGGER set_timestamp_flashcards
BEFORE UPDATE ON flashcards
FOR EACH ROW
EXECUTE FUNCTION trigger_set_timestamp();
```

### d. `ai_generation_events`

Logs events related to AI flashcard generation, including costs and statistics.

```sql
CREATE TABLE ai_generation_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    source_text_id UUID NOT NULL REFERENCES source_texts(id) ON DELETE CASCADE, -- Cascade if source text is deleted
    llm_model_used VARCHAR(255), -- e.g., 'gpt-3.5-turbo'
    generated_cards_count INTEGER NOT NULL DEFAULT 0,
    accepted_cards_count INTEGER NOT NULL DEFAULT 0,
    rejected_cards_count INTEGER NOT NULL DEFAULT 0,
    cost NUMERIC(10, 4), -- Assuming cost with 4 decimal places
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW() -- To track updates to accepted/rejected counts
);

CREATE TRIGGER set_timestamp_ai_generation_events
BEFORE UPDATE ON ai_generation_events
FOR EACH ROW
EXECUTE FUNCTION trigger_set_timestamp();
```

### e. `user_flashcard_spaced_repetition`

Manages spaced repetition learning data for each user and flashcard.

```sql
CREATE TABLE user_flashcard_spaced_repetition (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    flashcard_id UUID NOT NULL REFERENCES flashcards(id) ON DELETE CASCADE,
    due_date TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    current_interval INTEGER NOT NULL DEFAULT 1, -- Interval in days, or relevant unit for SR algorithm
    last_reviewed_at TIMESTAMPTZ,
    data_extra JSONB, -- For any additional data required by the SR algorithm
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    CONSTRAINT uq_user_flashcard_repetition UNIQUE (user_id, flashcard_id)
);

CREATE TRIGGER set_timestamp_user_flashcard_spaced_repetition
BEFORE UPDATE ON user_flashcard_spaced_repetition
FOR EACH ROW
EXECUTE FUNCTION trigger_set_timestamp();
```

## 2. Relationships Between Tables

-   **`auth.users` to `source_texts`**: One-to-Many. A user can have multiple source texts. `source_texts.user_id` -> `auth.users.id`.
-   **`auth.users` to `flashcards`**: One-to-Many. A user can have multiple flashcards. `flashcards.user_id` -> `auth.users.id`.
-   **`auth.users` to `ai_generation_events`**: One-to-Many. A user can have multiple AI generation events. `ai_generation_events.user_id` -> `auth.users.id`.
-   **`auth.users` to `user_flashcard_spaced_repetition`**: One-to-Many (indirectly, through flashcards). A user has repetition data for their flashcards. `user_flashcard_spaced_repetition.user_id` -> `auth.users.id`.
-   **`source_texts` to `flashcards`**: One-to-Many (Optional). A source text can be the origin for multiple AI-generated flashcards. `flashcards.source_text_id` -> `source_texts.id`. This relation is `ON DELETE SET NULL`.
-   **`source_texts` to `ai_generation_events`**: One-to-Many. A source text can be associated with multiple AI generation events (though typically one primary generation event). `ai_generation_events.source_text_id` -> `source_texts.id`. This relation is `ON DELETE CASCADE`.
-   **`flashcards` to `user_flashcard_spaced_repetition`**: One-to-Many (per user). A flashcard can have spaced repetition data for multiple users (though in this RLS-scoped model, it's effectively one-to-one within a user's data). `user_flashcard_spaced_repetition.flashcard_id` -> `flashcards.id`. This relation is `ON DELETE CASCADE`.

## 3. Indexes

Indexes are created to improve query performance. Foreign key constraints automatically create indexes on the referencing columns in PostgreSQL for some operations, but explicit index creation is good practice for clarity and performance tuning.

-   **On `source_texts`**:
    -   `CREATE INDEX idx_source_texts_user_id ON source_texts(user_id);`
-   **On `flashcards`**:
    -   `CREATE INDEX idx_flashcards_user_id ON flashcards(user_id);`
    -   `CREATE INDEX idx_flashcards_source_text_id ON flashcards(source_text_id);`
    -   `CREATE INDEX idx_flashcards_source ON flashcards(source);`
    -   `CREATE INDEX idx_flashcards_status ON flashcards(status);`
-   **On `ai_generation_events`**:
    -   `CREATE INDEX idx_ai_generation_events_user_id ON ai_generation_events(user_id);`
    -   `CREATE INDEX idx_ai_generation_events_source_text_id ON ai_generation_events(source_text_id);`
-   **On `user_flashcard_spaced_repetition`**:
    -   `CREATE INDEX idx_user_flashcard_spaced_repetition_user_id ON user_flashcard_spaced_repetition(user_id);`
    -   `CREATE INDEX idx_user_flashcard_spaced_repetition_flashcard_id ON user_flashcard_spaced_repetition(flashcard_id);`
    -   `CREATE INDEX idx_user_flashcard_spaced_repetition_due_date ON user_flashcard_spaced_repetition(due_date);`

## 4. PostgreSQL Row Level Security (RLS) Policies

RLS is implemented to ensure that users can only access and manage their own data.

**General Approach:**
For each table containing user-specific data (`source_texts`, `flashcards`, `ai_generation_events`, `user_flashcard_spaced_repetition`), RLS will be enabled. Policies will be created to allow operations (SELECT, INSERT, UPDATE, DELETE) only if the `user_id` column in the row matches the ID of the currently authenticated user (`auth.uid()`).

**Example Policy Structure (for `flashcards` table):**

```sql
-- Enable RLS on the table
ALTER TABLE flashcards ENABLE ROW LEVEL SECURITY;

-- Policy for SELECT: User can only see their own flashcards
CREATE POLICY "Allow user to see their own flashcards"
ON flashcards
FOR SELECT
USING (auth.uid() = user_id);

-- Policy for INSERT: User can only insert flashcards for themselves
CREATE POLICY "Allow user to insert their own flashcards"
ON flashcards
FOR INSERT
WITH CHECK (auth.uid() = user_id);

-- Policy for UPDATE: User can only update their own flashcards
CREATE POLICY "Allow user to update their own flashcards"
ON flashcards
FOR UPDATE
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Policy for DELETE: User can only delete their own flashcards
CREATE POLICY "Allow user to delete their own flashcards"
ON flashcards
FOR DELETE
USING (auth.uid() = user_id);
```

Similar policies need to be created for `source_texts`, `ai_generation_events`, and `user_flashcard_spaced_repetition` tables, replacing `flashcards` with the respective table name and ensuring the `user_id` column is correctly referenced.

## 5. Additional Notes and Design Decisions

1.  **UUIDs as Primary Keys**: `UUID`s are used as primary keys for all custom tables to facilitate distributed systems, prevent enumeration attacks, and simplify merging data if needed in the future.
2.  **Timestamps**: `created_at` and `updated_at` columns are included in all major tables to track record creation and modification times. `updated_at` is automatically updated by the `trigger_set_timestamp` trigger.
3.  **`ON DELETE` Policies**:
    -   Most user-related data employs `ON DELETE CASCADE` (e.g., if a user is deleted, their flashcards, source texts, AI events, and repetition data are also deleted). This supports GDPR "right to be forgotten".
    -   The relationship from `flashcards.source_text_id` to `source_texts.id` uses `ON DELETE SET NULL`. If a source text is deleted, associated AI-generated flashcards are not deleted but their link to the source text is removed. This allows flashcards to exist even if the original generation context is gone, but they would lose the direct tie.
4.  **Data Integrity**: `CHECK` constraints and `ENUM` types are used to maintain data integrity, particularly for the `source` and `status` fields in the `flashcards` table.
5.  **Spaced Repetition Flexibility**: The `user_flashcard_spaced_repetition.data_extra` (JSONB) field provides flexibility to store any additional parameters required by the chosen spaced repetition algorithm without altering the schema.
6.  **Cost Tracking**: The `ai_generation_events.cost` field (NUMERIC(10,4)) allows for precise tracking of costs associated with LLM API usage.
7.  **Future Scalability**: The schema is designed with scalability in mind, using appropriate data types and indexing strategies. Further denormalization or specialized read-replicas can be considered if performance bottlenecks arise with high data volume.
8.  **Security**: Beyond RLS, application-level checks and proper use of Supabase's authentication and authorization features are crucial for overall security.

This schema provides a solid foundation for the 10x-cards application's MVP.
