import uuid
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, ConfigDict, Field


# Enums
class FlashcardSourceEnum(str, Enum):
    MANUAL = "manual"
    AI_SUGGESTION = "ai_suggestion"


class FlashcardStatusEnum(str, Enum):
    ACTIVE = "active"
    PENDING_REVIEW = "pending_review"
    REJECTED = "rejected"


# Base Models (from Row types)
# These models represent the data as it is stored in the database (or returned from queries)
class AiGenerationEventBase(BaseModel):
    id: uuid.UUID = Field(default_factory=uuid.uuid4)
    user_id: uuid.UUID  # Assuming user_id is also a UUID
    source_text_id: uuid.UUID  # Assuming source_text_id is a UUID
    generated_cards_count: int
    accepted_cards_count: int
    rejected_cards_count: int
    llm_model_used: Optional[str] = None
    cost: Optional[float] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    model_config = ConfigDict(from_attributes=True)


class FlashcardBase(BaseModel):
    id: uuid.UUID = Field(default_factory=uuid.uuid4)
    user_id: uuid.UUID
    front_content: str
    back_content: str
    source: FlashcardSourceEnum
    status: FlashcardStatusEnum
    source_text_id: Optional[uuid.UUID] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    model_config = ConfigDict(from_attributes=True)


class SourceTextBase(BaseModel):
    id: uuid.UUID = Field(default_factory=uuid.uuid4)
    user_id: uuid.UUID
    text_content: str
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    model_config = ConfigDict(from_attributes=True)


class UserFlashcardSpacedRepetitionBase(BaseModel):
    id: uuid.UUID = Field(default_factory=uuid.uuid4)
    user_id: uuid.UUID
    flashcard_id: uuid.UUID
    due_date: datetime
    current_interval: int = Field(default=0)
    last_reviewed_at: Optional[datetime] = None
    data_extra: Optional[Dict[str, Any]] = None  # Corresponds to Json type
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    model_config = ConfigDict(from_attributes=True)


# Create Models (from Insert types)
# These models are for data validation when creating new records
class AiGenerationEventCreate(BaseModel):
    user_id: uuid.UUID
    source_text_id: uuid.UUID
    generated_cards_count: int = 0
    accepted_cards_count: int = 0
    rejected_cards_count: int = 0
    llm_model_used: Optional[str] = None
    cost: Optional[float] = None
    # id, created_at, updated_at are typically generated by the database or ORM


class FlashcardCreate(BaseModel):
    user_id: uuid.UUID
    front_content: str
    back_content: str
    source: FlashcardSourceEnum
    status: FlashcardStatusEnum = FlashcardStatusEnum.PENDING_REVIEW
    source_text_id: Optional[uuid.UUID] = None


class SourceTextCreate(BaseModel):
    user_id: uuid.UUID
    text_content: str


class UserFlashcardSpacedRepetitionCreate(BaseModel):
    user_id: uuid.UUID
    flashcard_id: uuid.UUID
    due_date: datetime
    current_interval: int = 1
    last_reviewed_at: Optional[datetime] = None
    data_extra: Optional[Dict[str, Any]] = None


# Update Models (from Update types)
# These models are for data validation when updating existing records, all fields are optional
class AiGenerationEventUpdate(BaseModel):
    user_id: Optional[uuid.UUID] = None
    source_text_id: Optional[uuid.UUID] = None
    generated_cards_count: Optional[int] = None
    accepted_cards_count: Optional[int] = None
    rejected_cards_count: Optional[int] = None
    llm_model_used: Optional[str] = None
    cost: Optional[float] = None
    # updated_at is often handled automatically


class FlashcardUpdate(BaseModel):
    user_id: Optional[uuid.UUID] = None
    front_content: Optional[str] = None
    back_content: Optional[str] = None
    source: Optional[FlashcardSourceEnum] = None
    status: Optional[FlashcardStatusEnum] = None
    source_text_id: Optional[uuid.UUID] = None


class SourceTextUpdate(BaseModel):
    user_id: Optional[uuid.UUID] = None
    text_content: Optional[str] = None


class UserFlashcardSpacedRepetitionUpdate(BaseModel):
    user_id: Optional[uuid.UUID] = None
    flashcard_id: Optional[uuid.UUID] = None
    due_date: Optional[datetime] = None
    current_interval: Optional[int] = None
    last_reviewed_at: Optional[datetime] = None
    data_extra: Optional[Dict[str, Any]] = None


# Schemas for API responses (often similar to Base models but can be customized)
class AiGenerationEvent(AiGenerationEventBase):
    pass


class Flashcard(FlashcardBase):
    pass


class SourceText(SourceTextBase):
    pass


class UserFlashcardSpacedRepetition(UserFlashcardSpacedRepetitionBase):
    pass


# If you need to represent the full 'Database' structure or relationships more explicitly,
# you might define further Pydantic models or use features like SQLModel that combine
# Pydantic models with ORM capabilities.
# For now, these models cover the table structures for typical CRUD operations.
